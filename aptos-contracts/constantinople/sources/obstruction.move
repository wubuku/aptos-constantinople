// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module aptos_constantinople_demo::obstruction {
    use aptos_constantinople_demo::position::Position;
    use aptos_framework::account;
    use aptos_framework::event;
    use aptos_std::table::{Self, Table};
    friend aptos_constantinople_demo::obstruction_create_logic;
    friend aptos_constantinople_demo::obstruction_aggregate;

    const EIdAlreadyExists: u64 = 101;
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const ENotInitialized: u64 = 110;

    struct Events has key {
        obstruction_created_handle: event::EventHandle<ObstructionCreated>,
    }

    struct Tables has key {
        obstruction_table: Table<Position, Obstruction>,
    }

    public fun initialize(store_account: &signer) {
        move_to(store_account, Events {
            obstruction_created_handle: account::new_event_handle<ObstructionCreated>(store_account),
        });

        move_to(
            store_account,
            Tables {
                obstruction_table: table::new(),
            },
        );

    }

    struct Obstruction has store {
        position: Position,
        version: u64,
        value: bool,
    }

    public fun position(obstruction: &Obstruction): Position {
        obstruction.position
    }

    public fun version(obstruction: &Obstruction): u64 {
        obstruction.version
    }

    public(friend) fun set_value(obstruction: &mut Obstruction, value: bool) {
        obstruction.value = value;
    }

    fun new_obstruction(
        position: Position,
        value: bool,
    ): Obstruction {
        Obstruction {
            position,
            version: 0,
            value,
        }
    }

    struct ObstructionCreated has store, drop {
        position: Position,
        value: bool,
    }

    public fun get_obstruction_created_all_properties(obstruction_created: &ObstructionCreated): (Position, bool) {
        (obstruction_created.position, obstruction_created.value)
    }

    public(friend) fun new_obstruction_created(
        position: Position,
        value: bool,
    ): ObstructionCreated {
        ObstructionCreated {
            position,
            value,
        }
    }


    public(friend) fun create_obstruction(
        store_address: address,
        position: Position,
        value: bool,
    ): Obstruction acquires Tables {
        asset_obstruction_not_exists(store_address, position);
        let obstruction = new_obstruction(
            position,
            value,
        );
        obstruction
    }

    public(friend) fun asset_obstruction_not_exists(
        store_address: address, position: Position,
    ) acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global_mut<Tables>(store_address);
        assert!(!table::contains(&tables.obstruction_table, position), EIdAlreadyExists);
    }

    public(friend) fun update_version_and_add(store_address: address, obstruction: Obstruction) acquires Tables {
        obstruction.version = obstruction.version + 1;
        //assert!(obstruction.version != 0, EInappropriateVersion);
        private_add_obstruction(store_address, obstruction);
    }

    public(friend) fun add_obstruction(store_address: address, obstruction: Obstruction) acquires Tables {
        assert!(obstruction.version == 0, EInappropriateVersion);
        private_add_obstruction(store_address, obstruction);
    }

    public(friend) fun remove_obstruction(store_address: address, position: Position): Obstruction acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global_mut<Tables>(store_address);
        table::remove(&mut tables.obstruction_table, position)
    }

    fun private_add_obstruction(store_address: address, obstruction: Obstruction) acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global_mut<Tables>(store_address);
        table::add(&mut tables.obstruction_table, obstruction.position, obstruction);
    }

    public fun get_all_porperties(store_address: address, position: Position): bool acquires Tables {
        assert!(exists<Tables>(store_address), ENotInitialized);
        let tables = borrow_global<Tables>(store_address);
        let obstruction = table::borrow(&tables.obstruction_table, position);
        all_porperties(obstruction)
    }

    public fun all_porperties(obstruction: &Obstruction): bool {
        obstruction.value
    }

    public(friend) fun drop_obstruction(obstruction: Obstruction) {
        let Obstruction {
            version: _version,
            position: _position,
            value: _value,
        } = obstruction;
    }

    public fun contains_obstruction(store_address: address, position: Position): bool acquires Tables {
        let tables = borrow_global<Tables>(store_address);
        table::contains(&tables.obstruction_table, position)
    }

    public(friend) fun emit_obstruction_created(store_address: address, obstruction_created: ObstructionCreated) acquires Events {
        assert!(exists<Events>(store_address), ENotInitialized);
        let events = borrow_global_mut<Events>(store_address);
        event::emit_event(&mut events.obstruction_created_handle, obstruction_created);
    }

}
